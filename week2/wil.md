객체지향 프로그래밍
    예외처리 :try,throw, catch 와 반복문:if , do while 문 정도가 기억난다.
    1. 오류가 발생 가능한 부분을 try로 감싼다.
    2. 오류가 발생할것 같은 부분에서 오류 값을 throw로 던진다 ex: throw(error)
    3. catch (int error) 같은 문으로 error 값을 캐치한다.
    ** throw 이후 코드는 진행되지 않는다 (break; 문이 자동으로 실행된다고 생각하면 될듯)** 
    
    do while: 일반적인 while 과 다르게 "무적권" 한번은 실행된다. 실용성이 있는지는 잘 몰루

수치해석: 
    엄큰수: INF - 2^-149 승 정도의 아주 큰 수를 엄큰 이라고 한다.
    a + (b +c) 에서 a = 엄큰 , b = -엄큰, c = -엄큰 이라고 하면 a + (b+c) != (a+ b) + c 이다.
    왜냐하면 (b + c) 는 INF로 변해버리기 때문이다... 그래서 망함~

디논:
    디논은근데 수업내용이 이해가 하나도 안간다.
    Minterm(최소항):SOP  곱의 합 이라고 생각하면 편함. 결과값이 1인 수식을 곱으로 표현해서 합친 식
    Maxterm(최대항):POS 얘는 합의 곱 이다. 결과값이 0인 수식을 합쳐서 표현한다.
    이것들을 짬뽕해가지고 여러가지 회로들을 간단히 만들수 있다~~~

    카르노맵: 교수피셜 가장 어려운 부분이라는데 나는 좀 쉬웠음.
    Minterm 으로 표현하고 진리표를 싹다 쓰면 되는데 , 여기서 중요한 부분이 있는데 ,
    만약 A,B 두 변수의 진리표를 적을때 00 , 01, 10 ,11 이렇게 순서대로 적는게 아니라 
    grey code 라고 해가지고 00, 01 ,11 ,10 이렇게 해야한다. 왜냐하면 그래야 숫자가 변할때마다 "비트가 하나씩" 만 변하기 때문이다.
    아무튼 그렇게 해서 진리표 바탕으로 카르노맵을 작성을 하며는 카르노맵에서 1또는 0을 SOP, POS 처럼 묶어야 하는데
    이때 2의 제곱수만큼만 묶을 수 있음. 직사각형의 변 크기가 1,2,4,8이 되도록만 묶을수잇다.
    그리고 만약 변수가 5개다? 그러면 4개로 카르노맵 만들고 5번째 x5변수는 0에 대응하는 4x4 카르노맵, 1에 대응하는 맵 하나 씩 해가지고 하면된다.
    D 어쩌구 저쩌구 주어지는 항이 있는데 얘는 Dont care :알빠노 항이다.1,0 중에 뭔 값이 들어가도 상관이없는 항임. 얘 잇으면 기분좋아야함.
    그리고 불 알게브라 공부를 좀 해야한다. 쉽지않음...

GIT 스터디:
    #star: star를 달면 북마크가 생긴다.
    #Issue:
    #Branch 기촌 브랜치에서 분기되어 생성되는 작업공간 (노리터), fork 와 달리 같은 레포지에 생성.
    #merge: 병합하는거임.
    1. Merge Commit
        " 두 브랜치를 공통 부모로 하는 새로운 commit ‘E’를 만들음.
        " A, B, C의 커밋이 그대로 main 브랜치로 병합
    2.squash and merge:
        얘는 그냥 뭉탱이로 갖다 박음. 한번에 main에다가 갖다박아버림.
    3.rebase:
        base를 재설정하고 새로운 커밋으로 변경함. 하나하나하나 다 새롭게 만들어버림. << 이놈 좀 위험